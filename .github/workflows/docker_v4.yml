name: Build Image and Deploy to EKS

on:
  push:
    branches:
      - feature-jm-sysadm #main
      #- '**'
jobs:

    build-and-push-private-ecr:
      runs-on: ubuntu-latest
      steps:

        - name: Checkout code
          uses: actions/checkout@v4
          with:
              fetch-depth: 0

        - name: Login AWS
          uses: aws-actions/configure-aws-credentials@v4
          with:
            aws-access-key-id: ${{ secrets.ACCESS_KEY }}
            aws-secret-access-key: ${{ secrets.SECRET_ACCESS_KEY }}
            aws-region: ${{ secrets.REGION }}

        - name: Login AWS-ECR
          uses: docker/login-action@v3
          with:
            registry: ${{ secrets.REGISTRY }}
            username: ${{ secrets.ACCESS_KEY }}
            password: ${{ secrets.SECRET_ACCESS_KEY }}
          env:
            aws-region: ${{ secrets.REGION }}

        # Agregar lógica para evaluar si el docker está en running y eliminarlo antes de desplegar una nueva versión
        - name: Build && Push Image to private ECR 
          id: build-and-push
          env: 
            REGISTRY: ${{ secrets.REGISTRY }}
            REPO: ${{ secrets.REPO }}
          run: |
            docker build -t ${REPO} .
            docker tag ${REPO}:latest ${REGISTRY}/${REPO}:${GITHUB_RUN_NUMBER}
            docker push ${REGISTRY}/${REPO}:${GITHUB_RUN_NUMBER}
            echo "image=${REGISTRY}/${REPO}:${GITHUB_RUN_NUMBER}" >> $GITHUB_OUTPUT

        - name: Add new task definition on ECS
          id: task_def
          uses: aws-actions/amazon-ecs-render-task-definition@v1
          with:
            task-definition: lab4-task-def-dso-jm-revision1.json
            container-name: lab4-app-deploy
            image: ${{ steps.build-and-push.outputs.image }}
  
        - name: Deploy Amazon ECS task definition
          uses: aws-actions/amazon-ecs-deploy-task-definition@v1
          with:
            task-definition: ${{ steps.task_def.outputs.task-definition }}
            service: lab4-app-deploy
            cluster: ${{ secrets.ECS_CLUSTER_NAME }}
            wait-for-service-stability: true

#     install_kubectl:
#       needs: build-and-push-private-ecr
#       runs-on: ubuntu-latest
#       steps:

#         - name: install_kubectl
#           run: |
#             curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
#             curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl.sha256"
#             echo "$(cat kubectl.sha256)  kubectl" | sha256sum --check
#             sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
#             kubectl version --client

# #----------------------------------------------->

#     deployToCluster:
#       needs: install_kubectl
#       runs-on: ubuntu-latest
#       steps:

#         - name: Checkout code
#           uses: actions/checkout@v4
#           with:
#             fetch-depth: 0

#         - name: Login AWS Credentials
#           uses: aws-actions/configure-aws-credentials@v4
#           with:
#             aws-access-key-id: ${{ secrets.ACCESS_KEY }}
#             aws-secret-access-key: ${{ secrets.SECRET_ACCESS_KEY }}
#             aws-region: ${{ secrets.REGION }}

#         - name: Download Kube File
#           env:
#             KUBECONFIG: ${{ runner.temp }}/kubeconfig
#           run: |
#             aws eks update-kubeconfig --name ${{ secrets.EKS_CLUSTER_NAME }} --region ${{ secrets.REGION }} --kubeconfig $KUBECONFIG
#             echo "KUBECONFIG=$KUBECONFIG" >> $GITHUB_ENV

#         - name: Deploy to EKS
#           env: 
#             REGISTRY: ${{ secrets.REGISTRY }}
#             REPO: ${{ secrets.REPO }}
#           run: |
#             sed -i "s|image: REPOSITORY_TAG|image: $REGISTRY/$REPO:$GITHUB_RUN_NUMBER|g" ./deployment.yml
#             # cat ./deployment.yml
#             kubectl apply -f ./deployment.yml
